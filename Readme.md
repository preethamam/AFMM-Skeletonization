# Augmented Fast Marching Method (AFMM) Skeletonization
"Skeletons and medial axes are of significant interest in many application areas such as object representation, flow visualization, path planning, medical visualization, computer vision, and computer animation. Skeletons provide a simple and compact representation of 2D or 3D shapes that preserves many of the topological and size characteristics of the original [1]." Skeletons are widely used in the crack width and length estimation problems. Skeleton extraction plays an important role in distinguishing the crack curvature and physcial properties in civil infrasturture maintenance. In this repository, two similar methods are implemented and presented in C, Python, Cython and Pybind:

1). Telea, Alexandru, and Jarke J. Van Wijk. "An augmented fast marching method for computing skeletons and centerlines." In EPRINTS-BOOK-TITLE. University of Groningen, Johann Bernoulli Institute for Mathematics and Computer Science, 2002. <br />
2). Reniers, Dennie, and Alexandru Telea. "Tolerance-based feature transforms." In Advances in Computer Graphics and Computer Vision: International Conferences VISAPP and GRAPP 2006, Set√∫bal, Portugal, February 25-28, 2006, Revised Selected Papers, pp. 187-200. Springer Berlin Heidelberg, 2007. <br />

## Methods
1. An augmented fast marching method for computing skeletons and centerlines is implemented in the [method_1](/method_1) folder. This AFMM method is a modified version from the original implementation of Alexandru et.al. [AFMM Star Implementation](https://webspace.science.uu.nl/~telea001/uploads/Software/AFMM/) and [Other Skeletonization implementations](https://webspace.science.uu.nl/~telea001/Software/Software). This method is implemented in MATLAB MEX by [Nicholas Howe](https://www.mathworks.com/matlabcentral/profile/authors/17831), original implementation can be found in [Better Skeletonization](https://www.mathworks.com/matlabcentral/fileexchange/11123-better-skeletonization). In [method_1](/method_1) folder you will find the ported implementations in `C`, `Python`, `Cython` and `Pybind`. Pybind implementations are Pythonic, exactly get C performance and easy to setup for any Python visrtual enviorments like `Anaconda`. `Cython` implementation is also quite similar to `C` performance. In contrast, native `Python` implementations are slower in computational time.
2. fefrfr
